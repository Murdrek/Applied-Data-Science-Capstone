# ðŸŽ¯ Objectives
# Perform exploratory Data Analysis and determine Training Labels
# Exploratory Data Analysis
# Determine Training Labels

# ðŸ“¦ Install required packages (if running in a fresh environment)
!pip install pandas
!pip install numpy

# ðŸ“š Import libraries
# Pandas is a software library written for the Python programming language for data manipulation and analysis.
import pandas as pd
#NumPy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays
import numpy as np

# Data Analysis
# Load Space X dataset, from last section.
df=pd.read_csv("https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DS0321EN-SkillsNetwork/datasets/dataset_part_1.csv")
df.head(10)

# Identify and calculate the percentage of the missing values in each attribute
df.isnull().sum()/len(df)*100
# Identify which columns are numerical and categorical:
df.dtypes

# TASK 1: Calculate the number of launches on each site
# The data contains several Space X launch facilities: Cape Canaveral Space Launch Complex 40 VAFB SLC 4E , Vandenberg Air Force Base Space Launch Complex 4E (SLC-4E), Kennedy Space Center Launch Complex 39A KSC LC 39A .The location of each Launch Is placed in the column LaunchSite
# Next, let's see the number of launches for each site.
# Use the method value_counts() on the column LaunchSite to determine the number of launches on each site:
# Apply value_counts() on column LaunchSite
# Aplicar value_counts() sobre la columna LaunchSite
df['LaunchSite'].value_counts()

# TASK 2: Calculate the number and occurrence of each orbit
# Use the method .value_counts() to determine the number and occurrence of each orbit in the column Orbit
# Note: Do not count GTO, as it is a transfer orbit and not itself geostationary.
# Apply value_counts on Orbit column
# Aplicar value_counts() excluyendo GTO
df[df['Orbit'] != 'GTO']['Orbit'].value_counts()

# TASK 3: Calculate the number and occurence of mission outcome of the orbits
# Use the method .value_counts() on the column Outcome to determine the number of landing_outcomes.Then assign it to a variable landing_outcomes.
# landing_outcomes = values on Outcome column
# Aplicar value_counts() sobre la columna Outcome
landing_outcomes = df['Outcome'].value_counts()
landing_outcomes

# True Ocean means the mission outcome was successfully landed to a specific region of the ocean while False Ocean means the mission outcome was unsuccessfully landed to a specific region of the ocean. True RTLS means the mission outcome was successfully landed to a ground pad False RTLS means the mission outcome was unsuccessfully landed to a ground pad.True ASDS means the mission outcome was successfully landed to a drone ship False ASDS means the mission outcome was unsuccessfully landed to a drone ship. None ASDS and None None these represent a failure to land.
for i,outcome in enumerate(landing_outcomes.keys()):
    print(i,outcome)

# We create a set of outcomes where the second stage did not land successfully:
bad_outcomes=set(landing_outcomes.keys()[[1,3,5,6,7]])
bad_outcomes

# TASK 4: Create a landing outcome label from Outcome column
# Using the Outcome, create a list where the element is zero if the corresponding row in Outcome is in the set bad_outcome; otherwise, it's one. Then assign it to the variable landing_class:
# landing_class = 0 if bad_outcome
# landing_class = 1 otherwise
# ðŸ§  ClasificaciÃ³n binaria del resultado de aterrizaje
# landing_class = 0 si el resultado estÃ¡ en bad_outcomes (fallido)
# landing_class = 1 en caso contrario (exitoso)

landing_class = [0 if outcome in bad_outcomes else 1 for outcome in df['Outcome']]
df.head(5)

# We can use the following line of code to determine the success rate:
df["Class"].mean()
df[df['Outcome'] == 'True ASDS'].shape[0]

# We can now export it to a CSV for the next section,but to make the answers consistent, in the next lab we will provide data in a pre-selected date range.
df.to_csv("dataset_part_2.csv", index=False)

